# 名词术语解释
- 引用计数：每个对象维护一个引用计数，当接口指针被复制的时候，计数增加；接口指针被销毁的时候，计数减少。使得客户可以以直观的方式使用接口指针。
- 名字对象[16-2]:名字对象本身也是一个COM对象。名字对象为另一个COM对象提供了的符号化的表示方法，同时也对组件对象的创建过程进行封装。客户程序只需创建相应的名字对象，并使用名字对象的绑定功能得到组件对象。
- 类型库[13-3]:类型库以机器可读的方式描述了组件与外界交互的必要信息. 如COM对象的CLSID, 它支持的接口的IID,接口的成员函数的签名等等,本质上它等价于描述接口的C/C++头文件。
- 双接口: 既通过分发接口给外界提供分发调用服务，也通过虚表来提供
- 可连接对象[14-7]：支持出接口（组件对象主动与客户通讯）的对象称为可连接对象，或源对象。
- 结构化存储[15-3]：结构化存储把文件系统的概念引入到文件内部,在文件内部构造一个树状层次结构。由存储对象和流对象构成。从而在存储结构上支持多应用程序的并发访问。
- WCF中的消息协定[WCF-1-30]:描述消息的格式，声明消息元素应包含在消息头中还是包含在消息正文中，
- WCF中的数据协定[WCF-1-32]:服务使用的数据类型必须在元数据中进行描述，以使其他各方可以与该服务进行交互操作。数据类型可以在消息的任何部分使用（例如，作为参数或返回类型）。如果服务仅使用简单类型，则无需显式使用数据协定。 对消息的何种元素应用何种级别的安全性等进行说明。 

# 分布式计算概述
## 分布式计算技术
- RPC
    RPC(远程过程调用)是第一个获得广泛认可的分布式计算技术。使用RPC，客户应用程序可以调用在远程计算机上实现的C语言函数。ONCRPC和DCE是主流标准。数据传输之前，先进行列集(marshaling)，然后通过网络协议传到通讯的另一端，读取数据时，先对数据进行散集(unmarshaling)，它是列集的相反过程。
- COBA
    COBA包括服务：命名服务，事件服务，通知服务，交易服务，事务服务。
- 消息队列
    消息队列是由System V引入的进程间通讯（IPC）的一种机制。
- COM
    可重用组件；由组件、对象、接口组成；有语言无关性、进程透明性、可重用性、多线程特性的众多特性。

# C++
## 类
- 构造函数可以重载(多种参数类型),析构函数不能重载(无参数)
- 构造函数不能是虚函数.(构造时必须指明类型).析构函数可以是(往往是)虚函数.(用来释放子类的内存).
## 虚函数
普通函数解析名字
虚函数根据虚表指针
晚绑定
## 多态
多态是指编译期无法确定函数
## RTTI(Run-Time Type Information)
为了一致性,往往把基类指针指向子类对象.而且这样做总是安全的.
面对一个基类指针,在行动之前,要准确地探明它指向的是什么.即RTTI.
- 直接使用子类方法: 编译期出错。
- 向下转换后使用子类方法: 潜在的运行期错误
## 类型转换
- 向上转换(upcasting)：子类向父类转换
    - 显式转换、隐式转换均可
- 向下转换(downcasting)：父类向子类转换
    - 只能显式转换，隐式转换无法通过编译
    - 可能出现运行时错误
- 交叉转换(crosscast): 共同继承一个父类的两个子类之间的转换
    - 只能显式转换
    - 并不安全.虚表中的可见部分不能被改变. 故声明虚函数成员的次序很重要
- 动态转换
    性能慢，只能进行向上转换
- 静态转换
    不能提供安全性
    不支持交叉转换
## 名字改编
实现重载的方式，没有标准不统一
## 参数传递的方式
- 引用
    &b = a, b是a的别名，没有创建新变量
- 值
    C++中缺省的参数初始化方法是把实参的值拷贝到参数的存储区中. 形参的值可以改变, 但此函数并不能改变实参的值.
- 地址
## 动态链接与静态链接

- 静态链接：库文件在Windows/Linux下的后缀名分别为.lib/.o
- 动态链接：库文件在Windows/Linux下的后缀名分别为.dll/.so

- 静态链接：在链接阶段，将用到的库函数与客户程序生成的目标文件合并成可执行文件。
- 动态链接：在运行时，动态地调用库文件。

- 静态链接：可执行文件会很大，而且浪费内存空间（两个程序调用了同样的库，内存里占了两份空间）。库代码更新需要重新编译所有的客户程序
- 动态链接：在运行时，动态地调用库文件。
  DLL可以向外引出变量、函数、资源、类

# C++到COM
走一遍实现COM组件的流程是必不可少的。与语言无关、与编译器无关。
1. 直接输出实现类
```cpp

```
生成DLL，同一编译器下的客户端就可以使用这个DLL了。而用不同的编译器就有可能出错，原因在于C++有函数重载的feature，通过名字改编实现。（编译时会给同名函数加上不同的前后缀来区分）而不同的编译器名字改编的方式不同，导致COM对象依赖于编译器。
2. 消除编译器相关性
   编译器相关性的来源：
- 普通函数会经历名字改编，而名字改编具有编译器相关性
- 将普通函数改为虚函数，
  虚函数是通过，所以定义接口，其中的。
  用`extern C`的方式输出`CreateObject()`返回实现类的指针，就可以在客户端定义实例
## 资源管理(引用计数)
在实现COM组件时，常会出现这样的情况:
- 两个指针指向的是同一个对象。
- 分别通过两个指针调用Delete是等价的。
- 其中一个指针调用Delete将会引起另一指针的失效。
  因此： 对同一个对象必须且只能调用一次Delete。
  而在上述情况下:
- 指针没有独立的生命周期。
- 指针之间的过渡耦合。
- 客户看不见的对象决定了指针的生命
  所以必须割裂指针之间的高度耦合（至少在形式上），让指针具有独立的生命周期。
  解决方法是: 每个对象维护一个引用计数，当接口指针被复制的时候，计数增加；接口指针被销毁的时候，计数减少。
## C++对象和COM对象
COM中组件与客户程序的解耦合依赖于RTTI，体现在以多接口实现的升级


# COM对象
设计模式的客观由来:把对象内部的工作细节对客户隐藏起来。使得实现类内部的数据成员的数量、类型以及内部的方法都可以发生变化，而客户程序无需重新编译。客户在运行时询问对象，以便发现对象的扩展功能。
## COM的原理
COM不仅定义了组件程序之间进行交互的标准,并且也提供了组件程序运行所需的环境,在 COM标准中，一个组件程序也被称为一个模块，它可以是一个动态链接库，被称为进程内组件(in-process component)；也可以是一个可执行程序（即 EXE 程序），被称作进程外组件(out-of-process component)。
COM特性: 语言无关、可重用性、进程透明性、多线程特性
## COM库函数
- `DllGetClassObject()`: 创建类厂
- `DllRegisterServer()`: 注册进程内组件
- `DllUnRegisterServer()`: 注销进程内组件
- `DllCanUnloadNow()`: 判断锁计数器和组件对象个数计数器是否都为零
- `CoGetClassObject()`: 从注册表中查找组件clsid程序的路径名，然后加载组件到内存，再调用`DllGetClassObject()`以创建类厂接口对象并返回指针。
- `CoCreateInstance()`: 封装了`DllGetClassObject()` + `pClassObject->CreateInstance()`，即先得到类厂，再调用类厂的方法创建实现类的实例
- `CoFreeUnusedLibrary()`: 安全卸载组件程序，调用`DllCanUnloadNow()`，如果引用和锁都为零，卸载。
  在使用COM库提供的函数之前要先调用`CoInitialize()`对COM库进行初始化，使用完以后使用`CoUnInitialize()`以释放COM库所维护的资源
## 客户程序与DLL对象交互
```cpp
CLSID clsid;
IClassFactory *pClf;
IUnknown *pUnknown;
CoInitialize(NULL);

// COM在注册表中查找字典的CLSID
CLSIDFromProgID(“Dictionary”,&clsid);

// COM库在内存中查找clsid组件，如果没有装入内存，从注册表中获取其路径加载到内存中。然后调用DllGetClassObject
// 组件程序创建类厂对象CDictionaryFactory，并返回IClassFactory接口
// COM库返回IClassFactory接口给客户
CoGetClassObject(clsid，CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory,(void**)&pClf); 

// 类厂对象的CreateInstance函数通过组件的vtable被客户直接调用。
// New Cdictionary;
// 返回IUnknown指针
pClf->CreateInstance(NULL,IID_IUnknown,(void**)&pUnknown);

/****************************************************

    客户使用字典对象，通过接口指针进行各种操作
    组件程序响应客户的操作

*****************************************************/

// 组件对象的Release被调用。如果计数为零，则删除自己。
pClf->Release();
pUnknown->Release();

// COM库调用字典组件的引出函数DllCanUnloadNow()
    // DllCanUnloadNow中：如果不存在字典对象，且锁计数器为零则返回真，否则为假
// 如果DllCanUnloadNow中返回真则CoFreeLibrary()；卸载组件程序
CoFreeUnusedLibraries()；

// COM库释放资源
CoUninitialize()；

/****************************************************

    客户程序退出

*****************************************************/
```


# COM的重用模型
如果我们新实现的组件其中一些功能是其他组件已有的，应该如何避免再造轮子把这些功能添加进来？
在源代码级，我们可能会使用继承的方法。

动态复合：除了使用单独的引用计数外,复合接口还可以进一步优化.一个COM子对象直到客户请求它的复合接口的时候才真正创建,可以进一步优化资源. 在特定的场合下有其重要的用途.这样的接口称为动态复合接口,也称为tearoff接口

下面的例子：A是已有组件，我们要实现B组件包含了A的功能。
## 包容
```
class IA:public IUnknown {
public:
    virtual HRESULT _stdcall fA() = 0;
}
class IB:public IUnknown {
public:
    virtual HRESULT _stdcall fB() = 0;
}

class B: public IB， public IA {
private:
    void Init();
    HRESULT fB();
    HRESULT fA();
    IA* pIA;
}
```
其中的`fA()`是通过调内部对象的方法实现的。
```
HRESULT B::fA() {
    return pIA->fA();
}
```
A在`B::Init()`中被创建。`B::Init()`在`BFactory::CreateInstance()`中被调用。
在包容模型中, 客户从来没有得到内部对象的指针
## 聚合
```
class B: public IB {
private:
    IUnknown* m_pUnknownInner; // 内部对象A的IUnknown接口指针
    IA* pIA; // 内部对象A的IA接口指针
}
B::QueryInterface {
    // 如果方法是IA的
    return m_pUnknownInner->QueryInterface(iid, ppv); // 用内部对象的IUnknown接口指针返回pIA;
}
```
核心是交叉转换
## 委托／非委托
当对象被正常使用的时候，委托IUnknown把调用传递给非委托的IUnknown; 当对象被聚合使用时, 委托IUnknown把调用传递到外部对象的IUnknown接口，并且这时外部对象通过非委托IUnknown接口对内部对象进行控制。


# 多线程模型
套间: COM把对象的并发性作为一个实现细节封装起来，客户无需知道这些细节,以简化对于不同线程特性的COM对象的调用过程. 为此,COM提出了一个规范的抽象的概念Apartment（套间，单元）以前称为执行环境（execution context)。
## 类型
### STA
- 优点: 驻留在STA中的对象不会被并发地访问，而且只有一个特定的线程可以访问(即也不允许多个线程串行地访问)。因此，对象的实现者可以方便安全地把各个方法调用过程中的中间状态保存在线程局部存储区中。或者说对象的数据成员是线程安全的
- 缺点: STA中如果有多个对象,对这些对象的调用也必须串行化地执行.因此,一个使用STA的可以并发访问的服务器,只好创建多个线程,每个线程创建一个套间,每个套间一个或多个对象.容易造成线程过多.
### MTA
MTA中的对象可以被此套间的多个线程同时访问。因此对象的数据成员缺乏保护。对象的实现者必须给以安全性保护.  当MTA中有多个对象时, 或者是调用次数频繁时, COM可以动态地申请线程.
一个进程中最多只能有一个MTA，但可以有多个STA
## 线程与套间的关系
- 当一个线程要使用一个COM对象时,必须先进入一个套间
- 线程只有在对象所处的的套间中才能访问对象
  单线程对象与Apartment对象的区别: 在第二个STA中创建一个单线程对象只能得到代理，而创建apartment对象将得到一个新的实例。
  线程模型与对象相关，而不是组件,也不是接口。
  服务器端：确定对象的套间类型。采取相应的数据保护措施。客户端：自由地进入各种套间，无需考虑线程问题。


# 自动化对象
在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。
COM架构的理想目标是：通过组合二进制组件来构成复杂的应用系统。

COM为了消除语言相关性，提出了IDL来描述接口，然后在IDL到具体的语言之间建立映射。然而数据类型与语言的关联程度还是很高（Java的指针）
## 早绑定与晚绑定
早绑定: 通过头文件/类型库，在开发客户程序时有关于接口的先验知识，这些先验信息帮助我们顺利编译客户程序。又称静态调用。

晚绑定: 不能使用类型库或其他的先验知识来描述接口的信息.这意味着对象自身要帮助脚本解释器,将文本形式的脚本代码翻译为有意义的方法调用.又称动态调用。
晚绑定的优点：开发阶段不进行类型检查,运行时决定组件的功能. 灵活性最高. 服务器接口发生变化,客户程序不用重现编译.

晚绑定的工作机制
```vb
Dim obj as Object;
Set obj=CreateObject(“MathLib.Math”) ;//动态创建，编译时不可知
obj.Add(10,20);//结果为30
Set obj=Nothing //释放对象
```
```cpp
IDispatch *pD;
HRESULT hr=CoCreateInstance(CLSID_Math, NULL, CLSCTX_SERVER, IID_IDispatch, &pD) ;//创建自动化对象,返回自动化接口
LPOLESTR lpOleStr=L”Add”; //加法,注意只是一个字符串
DISPATCH dispid;  
DISPPARAMS dms; //准备作加法的参数
memset(&dms,0,sizeof(DISPPARAMS));
dms.cArgs=2;  //有两个参数
VARIANTTAG*pArg=new VARIANTTAG[dms.cArgs]; //动态分配内存
dms.rgvarg=pArg;
memset(pArg,0,sizeof(VARIANT)*dms.cArgs);
dms.rgvarg[0].vt=VT_I4; //第一个参数是长整数
dms. rgvarg[0].lVal=10;  //值为10
dms.rgvarg[1].vt=VT_I4; //第二个参数也是长整数
dms. rgvarg[1].lVal=20;   //值为20
VARIANTARG vaResult;  //输出结果的参数
VariantInit(&vaResult);
hr=pD->Invoke(dispid, IID_NULL, LOCAL_SYSTEM_DEFAULT,DISPATCH_METHOD,&dispparams,&vaResult,0,NULL); //使用invoke,根据分发ID进行计算.输入计算参数,提供返回参数
pD->Release();  //释放接口
```

为了支持晚绑定,COM定义了一个接口,用来表达这种翻译机制,这个接口就是IDispatch.分发接口有时称为自动化接口,实现了此接口的对象称为自动化对象.

分发接口（自动化接口）与普通接口的区别：分发接口与普通接口的区别在于,接口的逻辑功能是如何被调用的.

- 实现了分发接口,没有提供类型库.只能使用晚绑定
- 实现了分发接口,提供了类型库,当然可以使用晚绑定,也可以使用DISPID绑定
- 实现了双接口,提供了类型库, 那么可以使用晚绑定,DISPID绑定和早绑定（直接使用虚表来调用接口的方法）；
# 可连接对象
## 双向调用的必要性
COM组件就是为了被调用而产生的，所以双向调用的必要性，其实讨论的就是COM对象调用客户程序的必要性。
如果组件程序是同步执行，那么调用操作是阻塞的，如果我们调用的函数十分费时，客户程序这边就一直卡着了。
```cpp
pIW->BiginWork();
```
如果组件程序是异步执行（组件程序添加进任务队列，立即返回），避免了阻塞的问题。但是去获取操作的结果就麻烦了。
```cpp
pIW->BiginWork();       //下达命令
BOOL Done=false;
while(!Done) {
    Sleep(10000);       // 无奈地等待
    pIW->IsOK(&Done);  // 再问一次
}
```
所以想到，由客户提供一个接口,这个接口可以供Waiter使用，在得到结果后去主动通知客户。

## 基本概念
入接口：客户调用，组件响应。单向通讯   IWaiter。
出接口：组件对象主动与客户通讯。组件调用，客户响应。对象通过出接口与客户通讯   INotify。
可连接对象：支持出接口的对象称为可连接对象，或源对象。（实现出接口的对象称为接收器）。
连接点机制：为了描述这种多对多的连接关系,COM使用一种更为通用的机制这就是连接点(connection point)机制。(一个可连接对象必须实现IConnectionPointContainer接口,用来管理所有的出接口,对于每一个出接口,源对象又管理一个连接点对象, 每个连接点对象都实现一个IConnectionPoint接口,每个连接点对象可以管理多个连接)

双向调用的必要性
为什么要引进接口（引进接口的必要性、基本原因、背景）*****
## COM客户端与可连接对象的交互过程
```cpp
HRESULT CWaiter::BeginWork(void) {
    assert(m_pIN); // 确保已经有了关联

    /****************************************************

        耗时操作

    *****************************************************/

    m_pIN->OnWorkIsOk(); // 通知客户
}

CNotify::OnWorkIsOk() {
    /****************************************************

        客户指定接下来的操作，或是单纯的通知

    *****************************************************/
}


// 客户程序中调用逻辑
HRESULT hr;
INotify * m_pIN = new CNotify;
IWaiter *pIW;
hr = CoCreateInstance(CLSID_Waiter, IID_IWaiter, &pIW);
pIW->Advise(m_pIN, &dwcookie);  //客户通过Advise方法提供与此接口任务相关的接口INotify, 而Waiter则返回一个代表这种关联的DWORD值.以后,这个值将被用来解除这种关联使用.
//客户使用UnAdvise通知Waiter解除与INotify的关联.  
pIW->BiginWork();   // 下达命令

/****************************************************

    客户程序接着执行，Waiter返回结果

*****************************************************/

// CNotify::OnWorkIsOk()被调用

```
# 结构化存储
# 名字对象
## 使用名字对象的原因
- 名字对象可以以名字的方式来创建COM对象,有时候比使用CLSID的方式更方便.
- 当COM对象之间形成了复杂的关系，如上下级、包容等。使用名字甚至复合名字，可以更合理地创建、还原COM对象。


# WCF
## 开发分布式应用系统的基本流程
1. 定义服务协定
   服务协定指定服务支持的操作。每个接口都必须包含`ServiceContractAttribute`特性,接口中的每个方法都对应于特定的服务操作，而每个操作都必须包含`OperationContractAttribute`特性以公开该方法，否则将不会公开。
>
    - 新建类库项目
    - 添加对System.ServiceModel.dll的引用。
        `using System.ServiceModel;`
    - 添加一个接口
    - 为接口增加ServiceContract 特性指明namespace
    - 为接口定义方法，为方法定义OperationContract特性。
2. 实现WCF服务协定,创建新类实现接口。
3. 承载和运行基本的WCF服务
    创建用于承载服务的控制台应用程序项目。
    为服务创建服务主机。
    启用元数据交换
    打开服务主机
    编译
    以管理员身份运行此程序，以完成服务的注册。
4. 创建WCF客户端
    创建一个控制台项目GettingStartedClient
    添加System.ServiceModel.dll引用
    ```csharp
    using System.ServiceModel;
    ```
# COM对象
COM对象的载体

# 其他
SOA（面向服务框架）的特点：可重用；松耦合；接口；无状态；开放标准