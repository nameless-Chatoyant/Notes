[comment]: # "题库按学习顺序，活用关键字搜索"
# 概述
```mermaid
graph LR;  
    字符流-->词法分析;
    词法分析-->token流;
    token流-->语法分析;
    语法分析-->抽象语法树;
    抽象语法树-->语义分析;
    语义分析-->中间代码;
    中间代码-->代码生成;
    代码生成-->目标代码
```
## 乔姆斯基文法体系
0型文法 - 任意文法
1型文法 - 上下文有关文法
2型文法 - 上下文无关文法 - 描述语法规则
3型文法 - 正则文法 - 描述词法规则
# 词法分析
- 正则表达式和FA
# 语法分析
分为
自顶向下分析: 从开始符号推导出句子，判断两句子是否相等
自底向上分析

## 自顶向下分析
### 回溯法
需要回溯，故要用前看符号避免回溯
### 递归下降分析法
为每个非终结符号都定义`parse()`
```
def parse_X():
    token = tokens[i]
    if token is a terminal:
        return
    elif token is a nonterminal:
        parse_Y()
```
根据上面的算法，左递归文法会产生无穷调用自身的情况
### LL(1)分析算法
文法存在左递归，则一定存在冲突
缺点
- 对每一个 X -> a·，会直接归约，紧跟goto
  会延迟错误发现的时机
- 可能包含冲突

#### 构造LL(1)分析表

#### LL(1)分析过程

## 自底向上分析
### LR(0)分析算法
ACTION GOTO
状态/符号
- 移进: 符号压入栈
- 归约: 栈顶上n个符号归约成产生式左部，新符号入栈
### SLR分析算法
SLR分析算法是对LR(0)分析算法的改进

缺点
- 对每一个 X -> a·，会直接归约，紧跟goto
  会延迟错误发现的时机
- 可能包含冲突

SLR
仅对y FOLLOW(X)添加ACTION(i, y)
### LR(1)分析算法

[跟LR(0)一样的, 向前搜索字符串]

初始closure({[S'->·S, $]})

### LALR
将LR(1)中类似项目集合并


## 语法制导翻译技术
继承属性: 由父结点/兄弟结点属性决定的属性
综合属性: 由子结点属性决定的属性
`<symbol, value, state>`
### 注释树
注释树 = 分析树 + 属性
### 语法树
语法树 = 分析树 - 无用部分
### 依赖图
每个符号的每个属性都是依赖图中的一个结点
属性的依赖是图中的边，决定方指向依赖方
# 语义分析
基于翻译技术，在语义动作中用if-(or)-then-else来判断
## 根据翻译方案写类型表达式
- 数组
    ```
    array(1...10, integer)
    ```
- 记录
    ```
    type row = record
                address: integer
                lexeme: array[1...15] of char
                end;
    ```
- 指针
    ```
    pointer(a)
    ```
- 函数
    ```
    定义域 -> 值域
    char x char -> pointer(integer)
    ```
## 符号表
典型表头
| 变量名  | 目标地址 | 类型 | 维数 | 声明行 | 引用行 | 指针 |
| ---- | ----- | ----- | ----- | ----- | ----- | ----- |
| ---- | ----- | ----- | ----- | ----- | ----- | ----- |



## 结构等价与名字等价
结构等价 < 名字等价
# 中间代码生成
## 三地址代码
### 基础
- 赋值语句
    ```
    x := y op z     # 二元
    x := op y       # 一元
    x := y          # 赋值
    ```
- 转移语句
    ```
    goto L          # 无条件转移到标号为L的语句
    if x relop y goto L # relop是关系运算符，如果不满足，执行下一句语句
    ```
- 过程调用语句
    ```
    param x         # 定义参数
    call p, n       # p为过程名, n为参数个数
    ```
- 含有数组元素的赋值语句
    ```
    x := y[i]
    x[i] := y

    x[i]
    ```
- 含有地址和指针的赋值语句
    ```
    x := &y
    x := *y
    *x := y
    ```
### 模板
    - loop
        ```
        1   i = 0
        2   if i < 10 goto()
        3   goto(N+1)
        4   循环体开始于此
        ...
        N-1 如果是for循环，在这里写步进
        N   goto(2)
        N+1
        ```
    - 数组访问
        作业题中的二维数组a[i,j]如何访问: 存在两种格式的
        ```
        offset = 
        aij = a + offset
        用*aij来访问
        ```
# 目标代码生成
基本块: 一个原子的语句集合
流图

# 运行时刻环境
## 参数传递方式
- 传值调用
- 引用调用
    即传地址调用，函数
- 复制恢复
    ```
    void swap(int a, int b) {

    }
    ```

- 传名调用
    宏替换，可以看作人肉copy调用代码块到调用位置，注意以下调用`swap(i,a[i])`
    ```c
    /* 预想功能: 交换i和a[i]的值 */
    temp = i;       // 保存了i的值
    i = a[i];       // a[i]的值赋给了i
    a[i] = temp;    // 这时i的值是a[i]的值，a[i]不是想要的位置
    ```
    作业题中的`swap()`结果比较，复制恢复和引用调用会交换，传值调用不交换，传名调用乱

## 访问链
## Display

# 题型
## 消除左递归
> 相关知识: 存在左递归会使**递归下降分析**陷入无限的递归
1. 消除间接左递归
    - 替代右值中的非终结符号: 以该非终结符号做左值的产生式的右值去替换非终结符号
    - 以右值代左值的产生式也要保留！
2. 消除直接左递归
    - 左递归产生式: A'->cA'
    - 非左递归产生式: 后面加A'

例题如下
```
S -> Aa|b
A -> Ac|Sd|ε

# 消除A -> Sd中的S
S -> Aa|b
A -> Ac|Aad     # 存在左递归
A -> bd|ε       # 不存在左递归

# 消除A -> Ac|Aad的直接左递归
A -> bdA'|εA'
A' -> cA'|adA'
```
## 提取左公因子
> 相关知识: 存在左公因子会使**LL(1)分析**产生冲突
## 求FIRST集
### 记忆
对$X \rightarrow a$
    $FIRST(X) \and = a$
对$X\rightarrow Y_1Y_2...Y_n$
$FIRST(N) \and = FIRST(Y_1)$
如果$Y_1 \rightarrow \episron$
    $FIRST(N) \and = FIRST(Y_2)$
如果$Y_1 \rightarrow \episron$ 并且 $Y_2 \rightarrow \epislon$
    $FIRST(N) \and = FIRST(Y_3)$
...
### 理解
对于单个非终结符号，有
- 对于A -> a, a属于FIRST(A)
- 对于A -> B, B -> b, 即A通过多次推导得出的位于开头的终结符号，也属于FIRST(A)
- 对于右值中存在ε的要小心, 如果A -> Ba, 而B -> ε, 那么就相当于A -> a, a属于FIRST(A)
  上述定义可以推广到串
## 求FOLLOW集
### 记忆
- FOLLOW(S) = {$}
- A -> αBβ, FIRST(β)中非ε属于FOLLOW(B)
- A -> αB或A -> αBβ且β能推导出ε, FOLLOW(A)属于FOLLOW(B)
### 理解
A -> αB或A -> αBβ且β能推导出ε, FOLLOW(A)属于FOLLOW(B)
以下举例
S -> Ac
A -> bB
## LL(1)分析表
```

```

## LL(1)分析过程
| 符号/状态 | 

## LR(1)分析表
| 状态 | action | goto |
| :---: | :---: | :---: |

## 拓广文法
- 保证开始符号`S'`不会出现在产生式右部
- 显式写出`$`符号

## 项目集规范族
### LR(0)
初始状态I_0
如果A -> α·Bβ在closure(I)中，即"期望读到下一个token是B"，然而B不是终结符号，其实期望读到的是B能推导出的右值，故把B作左值的产生式加入closure(I)
### LR(1)
如果[A -> α·Bβ, a]在closure(I)中，B -> η是产生式，对任意b属于FIRST(βa), [B -> ·η, b]closure(I)
剩余的输入能够匹配βa

## 根据语法制导定义进行移进归约

## 根据语法制导定义描述翻译过程
进行一般的移进归约，入栈的是三元组`<symbel, value, state>`，归约时会触发相应的语义规则

## 设计翻译方案

## 三地址代码划分基本块

## 综合属性替代继承属性
原语法制导定义
|     产生式     |                   语义规则                   |
| :---------: | :--------------------------------------: |
|   D -> TL   |             `L.in := T.type`             |
|  T -> int   |           `T.type := integer`            |
|  T -> real  |             `T.type := real`             |
| L -> L_1,id | `L1.in := L.in` `addtype(id.entry, L.in)` |
|   L -> id   |        `addtype(id.entry, L.in)`         |
其中`L.in`为继承属性
类型信息是从左往右流，而分析是从右向左归约，导致了分析期间不能完成属性的计算

改写的关键: 标识符由L产生，所以类型应在L的子树中
L -> TL|id|
参考5.5.4, 可以改为

从左向右归约，从右向左推导
|     产生式     |                   语义规则                   |
| :---------: | :--------------------------------------: |
|   D -> L    |                                          |
|  T -> int   |           `T.type := integer`            |
|  T -> real  |             `T.type := real`             |
| L -> L_1,id | `L.type := L1.type` `addtype(id.entry, L.type)` |
|  L -> Tid   | `L.type := T.type` `addtype(id.entry, L.type)` |

两种语法树对比
